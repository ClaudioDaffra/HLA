Sure! Here's the English translation of your documentation, preserving the original format and structure:

---

# nMOSLib Documentation

This documentation describes the macros, constants, and subroutines provided by the nMOSLib assembly library for 6502/6510 processors, with a specific focus on the Commodore 64, VIC-20, and C128 platforms.

## 1. Core Library (`nMOSLib/lib/libCD.asm`)

This file contains general-purpose definitions and macros, valid across all supported platforms.

### Platform Constants (`TARGET_*`)

Constants are defined to identify the target platform during compilation.

- TARGET_C64: 0  
- TARGET_VIC20: 1  
- TARGET_VIC20_3K: 2  
- TARGET_VIC20_8K: 3  
- TARGET_VIC20_16K: 4  
- TARGET_VIC20_24K: 5  
- TARGET_VIC20_32K: 6  
- TARGET_C128: 7

### Memory Constants

Constants are defined for memory addresses specific to each platform (e.g., `PROGRAM_ADDRESS_C64`, `SCREEN_ADDRESS_C64`, etc.). These constants are then used in platform-specific files.

### `PROGRAM` Macro

- **Purpose**: Generates a BASIC program header that executes a machine language routine via `SYS`.  
- **Syntax**: `PROGRAM _TARGET, _BASIC_ADDRESS, _LINE`  
- **Parameters**:  
  - `_TARGET`: Target platform (e.g., `TARGET_C64`)  
  - `_BASIC_ADDRESS`: Starting address of the BASIC program  
  - `_LINE`: BASIC line number  
- **Description**: Creates a BASIC line (e.g., `2025 SYS 2061`) that launches the assembly code. Initializes the stack (`fstack.init`), sets processor flags (`clc`, `cld`), calls the main routine, and ends with `rts`.

### Loading Macros

- `load_mem_ay \1`: Loads a 16-bit memory address into A (low byte) and Y (high byte)  
- `load_imm_ay \1`: Loads a 16-bit immediate value into A and Y  
- `load_address_ay \1`: Alias for `load_imm_ay`  
- `load_fac1 \1`: Loads a 5-byte floating-point number from memory into FAC1  
- `load_fac2 \1`: Loads a 5-byte floating-point number into FAC2  
- `load_addr_zpWord0 \1`: Loads an address into zero page location `zpWord0`  
- `load_addr_zpWord1 \1`: Loads an address into zero page location `zpWord1`

### PETSCII and Color Constants

- `petscii.nl`: 13 (New Line)  
- `petscii.clear_screen`: 147  
- `color.black`, `color.white`, etc.: Numeric constants for standard colors

### Zero Page Locations

Labels are defined for zero page locations used by the library, such as `zpa`, `zpy`, `zpWord0`, `zpDWord0`, etc., for easier and more readable access.

---

## 2. Platform-Specific Libraries

These files include KERNAL and BASIC routines specific to each computer.

### `nMOSLib/lib/c64/` (Commodore 64)

- `libCD_c64.asm`:  
  - Defines memory constants for the C64 (e.g., `SCREEN = $0400`)  
  - Includes `c64/libKERNEL_c64.asm`, `c64/libBASIC_c64.asm`, and general libraries  
- `libKERNEL_c64.asm`:  
  - `kernel.chrout ($F1CA -> $FFD2)`: Prints the character in register A  
- `libBASIC_c64.asm`:  
  - `basic.print_unsigned_integer ($BDCD)`: Prints an unsigned integer. Input: X (low), A (high)  
  - `basic.print_string ($AB1E)`: Prints a zero-terminated PETSCII string. Input: A (low addr), Y (high addr)  
  - `basic.conv_fac1_to_string ($BDDD)`: Converts FAC1 value to ASCII string starting at $0100  
  - `basic.conv_u8_to_fac1 ($B3A2)`: Converts byte in Y to floating-point in FAC1  
  - `basic.conv_s16_to_fac1 ($B391)`: Converts signed 16-bit integer in Y/A to floating-point in FAC1  
  - `basic.load5_fac1 ($BBA2)`: Loads 5 bytes into FAC1. Input: A/Y (address)  
  - `basic.store5_fac1_xy ($BBD4)`: Stores 5 bytes from FAC1 to memory. Input: X/Y (address)  
  - `basic.add_fac1_kb ($B86A)`: FAC1 := FAC1 + FAC2  
  - `basic.mul_fac1_kb ($BA2B)`: FAC1 := FAC1 * FAC2  
  - `basic.div_fac1_kb ($BB12)`: FAC1 := FAC2 / FAC1  
  - `basic.sub_fac1_kb ($B853)`: FAC1 := FAC2 - FAC1  
  - `basic.fac1_compare ($BC5B)`: Compares FAC1 with memory value. Input: A/Y (address). Output `A`: $00 (equal), $01 (FAC1 > MEM), $FF (FAC1 < MEM)

### `nMOSLib/lib/c128/` (Commodore 128)

- `libCD_c128.asm`:  
  - Defines memory constants for the C128  
  - Provides macros `c128_disable_rom` and `c128_enable_rom` to manage RAM under ROM  
- `libKERNEL_c128.asm`:  
  - `kernel.chrout ($FFD2)`: Prints the character in A  
- `libBASIC_c128.asm`:  
  - Routines similar to C64 but with different addresses (e.g., `_print_unsigned_integer` at $8E32)  
  - Routines are wrapped to disable/enable BASIC ROM

### `nMOSLib/lib/vic20/` (VIC-20)

- `libCD_vic20.asm`, `libCD_vic20_3k.asm`, etc.:  
  - Define memory constants for VIC-20 and its memory expansions  
- `libKERNEL_vic20.asm`:  
  - `kernel.chrout ($E109 -> $FFD2)`: Prints the character in A  
- `libBASIC_vic20.asm`:  
  - Routines similar to C64 but with different addresses (e.g., `_print_unsigned_integer` at $DDCD)

---

## 3. General-Purpose Libraries

### `nMOSLib/lib/libFSTACK.asm` (Fast Stack)

This library implements a software stack for managing local variables and function parameters.

- `fstack.init`: Initializes stack pointers (`sp` and `bp`)  
- `fstack.alloc`: Allocates bytes on stack for local variables. Input: A (size)  
- `fstack.lea_bp`: Computes effective address of a local variable. Input: A (offset). Output: A/Y (address)  
- `fstack.push.byte`, `fstack.push.word`, `fstack.push.real`: Pushes byte, word, or real number onto stack  
- `fstack.pop.byte`, `fstack.pop.word`, `fstack.pop.real`: Pops byte, word, or real number from stack  
- Macros: Simplify stack usage, e.g., `fstack_push_byte_fast` (uses `pha`), `fstack_pop_byte_fast` (uses `pla`), and macros to save/restore stack pointers (`fstack_push_sp_bp`, `fstack_pop_sp_bp`)

### `nMOSLib/lib/libMATH.asm` (Math Library)

Contains routines for arithmetic, logic, and comparison operations on various data types.

- **Arithmetic Operations**:  
  - `math.add_u16s16`: ay := ay + zpWord0  
  - `math.sub_u16s16`: ay := ay - zpWord0  
  - `math.mul_u8`: Multiplies two unsigned bytes. Input: A, Y. Output: A/Y (16-bit word)  
  - `math.mul_u16s16`: Multiplies two unsigned 16-bit words. Input: A/Y, zpWord0. Output: zpDWord1 (32-bit dword)  
  - `math.div_u8`: Divides two unsigned bytes. Input: A (numerator), Y (denominator). Output: A (quotient), Y (remainder)  
  - `math.div_u16`: Divides two unsigned 16-bit words. Input: zpWord0 (dividend), A/Y (divisor). Output: A/Y (result), zpWord1 (remainder)  
  - `math.add_f40`, `math.sub_f40`, `math.mul_f40`, `math.div_f40`: Floating-point operations (using BASIC ROM routines)  
  - `math.mod_f40`: Computes modulo between two floating-point numbers

- **Logical and Comparison Operations**:  
  - `math.not_u8s8`, `math.not_u16s16`: Logical NOT operator  
  - `math.u8_cmp_eq`, `math.u16_cmp_lt`, `math.s16_cmp_ge`, etc.: Full set of comparison routines (==, !=, <, <=, >, >=) for 8- and 16-bit integers, signed and unsigned  
  - `math.f40_cmp_eq`, `math.f40_cmp_lt`, etc.: Floating-point comparisons

