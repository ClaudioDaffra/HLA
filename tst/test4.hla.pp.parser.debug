--- Begin Parser Debug ---

Parser execution log:

  - Starting parser. Rule: <program> ::= <top_level_statement>*
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_namespace(). Rule: <namespace> ::= 'ns' T_IDENTIFIER '{' (<function> | <sys_function>)* '}' ';'
  - Entering parse_function(). Rule: <function> ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  - Matched 'fn'. Expecting function name (T_IDENTIFIER).
  - Final (mangled) function name is 'standard.print'.
  - Entered new scope for function 'standard.print'.
  - Matched function name 'print'. Expecting '('.
  - Parsing <param_list>.
  - Matched ')'. Expecting '->' for return type.
  - Matched '->'. Expecting return type specifier.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Created symbol for function 'standard.print'. Expecting '{'.
  - Parsing <block>.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_return_statement(). Rule: <return_statement> ::= 'ret' <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 0. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Created ND_RETURN node.
  - Finished parsing <block>. Expecting '}'.
  - Checking for name conflicts with function 'standard.print'.
  - Calculating stack offsets for function 'standard.print'.
  - Total stack size for 'standard.print': 0
  - Matched '}' and left scope. Expecting ';'.
  - Matched ';'. Function parsing complete.
  - Finished parsing namespace 'standard'.
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'varu16'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'varu16'. Expecting ';'.
  - Created symbol 'varu16' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_function(). Rule: <function> ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  - Matched 'fn'. Expecting function name (T_IDENTIFIER).
  - Final (mangled) function name is 'main'.
  - Entered new scope for function 'main'.
  - Special handling for 'main' function.
  - Matched '()'. Injecting default parameters for 'main'.
  -   - Injected 'argc: u8'.
  -   - Injected 'argv: ^^u16'.
  - Forcing return type to 'u8' for 'main'.
  - Created symbol for function 'main'. Expecting '{'.
  - Parsing <block>.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'vu8'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed type for 'vu8'. Expecting ';'.
  - Created symbol 'vu8' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'vu16'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'vu16'. Expecting ';'.
  - Created symbol 'vu16' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'vf40'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'vf40'. Expecting ';'.
  - Created symbol 'vf40' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pu8'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed type for 'pu8'. Expecting ';'.
  - Created symbol 'pu8' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pu16'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'pu16'. Expecting ';'.
  - Created symbol 'pu16' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pf40'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'pf40'. Expecting ';'.
  - Created symbol 'pf40' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'addr'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'addr'. Expecting ';'.
  - Created symbol 'addr' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pString'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed type for 'pString'. Expecting ';'.
  - Created symbol 'pString' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pString'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_STRING. Value: "claudio daffra".
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu8'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - Matched unary '@'. Creating ND_ADDR node.
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'vu8'. Creating ND_VAR node.
  -  -> Resulting type is '^u8'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu16'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - Matched unary '@'. Creating ND_ADDR node.
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'vu16'. Creating ND_VAR node.
  -  -> Resulting type is '^u16'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pf40'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - Matched unary '@'. Creating ND_ADDR node.
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'vf40'. Creating ND_VAR node.
  -  -> Resulting type is '^f40'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu8'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu8'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 1. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  -  -> Inserting implicit cast from 'u8' to 'u16'.
  -  -> Pointer arithmetic (ptr +/- int). Injecting scaling multiplication.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu16'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pu16'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 1. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  -  -> Inserting implicit cast from 'u8' to 'u16'.
  -  -> Pointer arithmetic (ptr +/- int). Injecting scaling multiplication.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pf40'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pf40'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 1. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  -  -> Inserting implicit cast from 'u8' to 'u16'.
  -  -> Pointer arithmetic (ptr +/- int). Injecting scaling multiplication.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pString'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_STRING. Value: "claudio daffra".
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Identifier 'standard.print' is a function call.
  - Parsing argument list for 'standard.print'.
  - Performing type checking for arguments of 'standard.print'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_return_statement(). Rule: <return_statement> ::= 'ret' <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 0. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Created ND_RETURN node.
  - Finished parsing <block>. Expecting '}'.
  - Checking for name conflicts with function 'main'.
  - Calculating stack offsets for function 'main'.
  -   - Symbol 'argc', size 1, offset 0
  -   - Symbol 'argv', size 2, offset 1
  -   - Symbol 'vu8', size 1, offset 3
  -   - Symbol 'vu16', size 2, offset 4
  -   - Symbol 'vf40', size 5, offset 6
  -   - Symbol 'pu8', size 2, offset 11
  -   - Symbol 'pu16', size 2, offset 13
  -   - Symbol 'pf40', size 2, offset 15
  -   - Symbol 'addr', size 2, offset 17
  -   - Symbol 'pString', size 2, offset 19
  - Total stack size for 'main': 21
  - Matched '}' and left scope. Expecting ';'.
  - Matched ';'. Function parsing complete.
  - Successfully matched EOF. Parsing complete.

Grammar implemented (with implicit casting):

  <program>             ::= <top_level_statement>*
  <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  <namespace>           ::= 'ns' T_IDENTIFIER '{' (<function> | <sys_function>)* '}' ';'
  <function>            ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  <sys_function>        ::= 'sys' T_IDENTIFIER '(' <sys_param_list> ')' ('->' <type_specifier>)? '{' <block> '}' ';'
  <param_list>          ::= (<param> (',' <param>)*)?
  <param>               ::= T_IDENTIFIER ':' <type_specifier>
  <sys_param_list>      ::= (<sys_param> (',' <sys_param>)*)?
  <sys_param>           ::= <sys_type> ':' <sys_destination>
  <sys_type>            ::= 'byte' | 'word' | 'real'
  <sys_destination>     ::= 'a' | 'x' | 'y' | 'ay' | 'ax' | 'xy' | 'fac1' | 'fac2' | T_IDENTIFIER
  <type_specifier>      ::= T_POINTER* T_IDENTIFIER
  <block>               ::= <statement>*
  <statement>           ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  <return_statement>    ::= 'ret' <expr> ';'
  <declaration>         ::= T_IDENTIFIER ':' <type_specifier> ';'
  <const_declaration>   ::= T_IDENTIFIER ':' <expr> ';'
  <asm_statement>       ::= T_ASM_BLOCK ';'
  <expr_statement>      ::= <expr> ';'
  <expr>                ::= <assign>
  <assign>              ::= <logical_or_and> (':=' <assign>)?
  <logical_or_and>      ::= <equality> (('&&' | '||') <equality>)*
  <equality>            ::= <relational> (('?=' | '!=') <relational>)*
  <relational>          ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  <add_sub>             ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  <mul_div_mod>         ::= <unary> (('*' | '/' | '%%') <unary>)*
  <unary>               ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  <postfix>             ::= <term> ('++' | '--')*
  <term>                ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  <func_call>           ::= (T_IDENTIFIER '::')? T_IDENTIFIER '(' <arg_list> ')'
  <arg_list>            ::= (<expr> (',' <expr>)*)?


--- End Parser Debug ---
