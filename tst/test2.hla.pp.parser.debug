--- Begin Parser Debug ---

Parser execution log:

  - Starting parser. Rule: <program> ::= <top_level_statement>*
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'a'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'a'. Expecting ';'.
  - Created symbol 'a' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pa'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'pa'. Expecting ';'.
  - Created symbol 'pa' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_function(). Rule: <function> ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  - Matched 'fn'. Expecting function name (T_IDENTIFIER).
  - Final (mangled) function name is 'sub1'.
  - Entered new scope for function 'sub1'.
  - Matched function name 'sub1'. Expecting '('.
  - Parsing <param_list>.
  - Parsing a parameter. Rule: <param> ::= T_IDENTIFIER ':' <type_specifier>
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed parameter 'px'.
  - Parsing a parameter. Rule: <param> ::= T_IDENTIFIER ':' <type_specifier>
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed parameter 'py'.
  - Parsing a parameter. Rule: <param> ::= T_IDENTIFIER ':' <type_specifier>
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed parameter 'pr'.
  - Matched ')'. Expecting '->' for return type.
  - Matched '->'. Expecting return type specifier.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Created symbol for function 'sub1'. Expecting '{'.
  - Parsing <block>.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'p1'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'p1'. Expecting ';'.
  - Created symbol 'p1' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'p2'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u16'.
  - Parsed type for 'p2'. Expecting ';'.
  - Created symbol 'p2' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_return_statement(). Rule: <return_statement> ::= 'ret' <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with suffix 's16'. Value: 1.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  -  -> Inserting implicit cast from 's16' to 'u8'.
  - Created ND_RETURN node.
  - Finished parsing <block>. Expecting '}'.
  - Checking for name conflicts with function 'sub1'.
  - Calculating stack offsets for function 'sub1'.
  -   - Symbol 'px', size 1, offset 0
  -   - Symbol 'py', size 2, offset 1
  -   - Symbol 'pr', size 5, offset 3
  -   - Symbol 'p1', size 2, offset 8
  -   - Symbol 'p2', size 2, offset 10
  - Total stack size for 'sub1': 12
  - Matched '}' and left scope. Expecting ';'.
  - Matched ';'. Function parsing complete.
  - Entering parse_top_level_statement(). Rule: <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  - Entering parse_function(). Rule: <function> ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  - Matched 'fn'. Expecting function name (T_IDENTIFIER).
  - Final (mangled) function name is 'main'.
  - Entered new scope for function 'main'.
  - Special handling for 'main' function.
  - Matched '()'. Injecting default parameters for 'main'.
  -   - Injected 'argc: u8'.
  -   - Injected 'argv: ^^u16'.
  - Forcing return type to 'u8' for 'main'.
  - Created symbol for function 'main'. Expecting '{'.
  - Parsing <block>.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'm1'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 's8'.
  - Parsed type for 'm1'. Expecting ';'.
  - Created symbol 'm1' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'm2'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed type for 'm2'. Expecting ';'.
  - Created symbol 'm2' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'pu8'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Matched pointer type specifier '^'.
  - Expecting type identifier.
  - Matched type identifier 'u8'.
  - Parsed type for 'pu8'. Expecting ';'.
  - Created symbol 'pu8' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'm3'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 's8'.
  - Parsed type for 'm3'. Expecting ';'.
  - Created symbol 'm3' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'm4'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 's16'.
  - Parsed type for 'm4'. Expecting ';'.
  - Created symbol 'm4' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'r1'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'r1'. Expecting ';'.
  - Created symbol 'r1' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'r2'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'r2'. Expecting ';'.
  - Created symbol 'r2' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'r3'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'r3'. Expecting ';'.
  - Created symbol 'r3' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'x'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'x'. Expecting ';'.
  - Created symbol 'x' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'y'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'y'. Expecting ';'.
  - Created symbol 'y' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_declaration(). Rule: <declaration> ::= T_IDENTIFIER ':' <type_specifier> ';'
  - Matched identifier 'z'. Expecting ':'.
  - Parsing type specifier for declaration.
  - Entering parse_type_specifier(). Rule: <type_specifier> ::= T_POINTER* T_IDENTIFIER
  - Expecting type identifier.
  - Matched type identifier 'f40'.
  - Parsed type for 'z'. Expecting ';'.
  - Created symbol 'z' and added to scope. Creating ND_VAR_DECL node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'm1'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Identifier 'sub1' is a function call.
  - Parsing argument list for 'sub1'.
  - Parsing an argument expression.
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 1. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsing an argument expression.
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with suffix 'u16'. Value: 128.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsing an argument expression.
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_REAL. Value: 1024.768.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Performing type checking for arguments of 'sub1'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  -  -> Inserting implicit cast from 'u8' to 's8'.
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pa'. Creating ND_VAR node.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - Matched unary '@'. Creating ND_ADDR node.
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'a'. Creating ND_VAR node.
  -  -> Resulting type is '^u16'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_expr_statement(). Rule: <expr_statement> ::= <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - Matched unary '^'. Creating ND_DEREF node.
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_IDENTIFIER 'pa'. Creating ND_VAR node.
  -  -> Resulting type is 'u16'.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Matched T_ASSIGN (:=). Creating ND_ASSIGN node.
  - Parsing right-hand side of ':='.
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with suffix 'u16'. Value: 123.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Parsed expression. Expecting ';'.
  - Matched ';'.
  - Wrapping expression in ND_EXPR_STMT.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_asm_statement(). Rule: <asm_statement> ::= T_ASM_BLOCK ';'
  - Matched T_ASM_BLOCK. Expecting ';'.
  - Matched ';'. Creating ND_ASM node.
  - Entering parse_statement(). Rule: <statement> ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  - Entering parse_return_statement(). Rule: <return_statement> ::= 'ret' <expr> ';'
  - Entering parse_expr(), delegating to parse_assign(). Rule: <expr> ::= <assign>
  - Entering parse_assign(). Rule: <assign> ::= <logical_or_and> (':=' <assign>)?
  - Entering parse_logical_or_and(). Rule: <logical_or_and> ::= <equality> (('&&' | '||') <equality>)*
  - Entering parse_equality(). Rule: <equality> ::= <relational> (('?=' | '!=') <relational>)*
  - Entering parse_relational(). Rule: <relational> ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  - Entering parse_add_sub(). Rule: <add_sub> ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  - Entering parse_mul_div_mod(). Rule: <mul_div_mod> ::= <unary> (('*' | '/' | '%%') <unary>)*
  - Entering parse_unary(). Rule: <unary> ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  - No prefix unary operator found. Parsing <postfix>.
  - Entering parse_postfix(). Rule: <postfix> ::= <term> ('++' | '--')*
  - Entering parse_term(). Rule: <term> ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  - Matched T_INTEGER with no suffix. Value: 0. Inferring type.
  - Inferred type: u8.
  - Parsed initial <unary>, now looking for '*', '/' or '%%'.
  - No more '*', '/' or '%%'. Exiting parse_mul_div_mod().
  - Parsed initial <mul_div_mod>, now looking for '+' or '-'.
  - No more '+' or '-'. Exiting parse_add_sub().
  - Created ND_RETURN node.
  - Finished parsing <block>. Expecting '}'.
  - Checking for name conflicts with function 'main'.
  - Calculating stack offsets for function 'main'.
  -   - Symbol 'argc', size 1, offset 0
  -   - Symbol 'argv', size 2, offset 1
  -   - Symbol 'm1', size 1, offset 3
  -   - Symbol 'm2', size 1, offset 4
  -   - Symbol 'pu8', size 2, offset 5
  -   - Symbol 'm3', size 1, offset 7
  -   - Symbol 'm4', size 2, offset 8
  -   - Symbol 'r1', size 5, offset 10
  -   - Symbol 'r2', size 5, offset 15
  -   - Symbol 'r3', size 5, offset 20
  -   - Symbol 'x', size 5, offset 25
  -   - Symbol 'y', size 5, offset 30
  -   - Symbol 'z', size 5, offset 35
  - Total stack size for 'main': 40
  - Matched '}' and left scope. Expecting ';'.
  - Matched ';'. Function parsing complete.
  - Successfully matched EOF. Parsing complete.

Grammar implemented (with implicit casting):

  <program>             ::= <top_level_statement>*
  <top_level_statement> ::= <namespace> | <function> | <sys_function> | <declaration> | <const_declaration> | <asm_statement>
  <namespace>           ::= 'ns' T_IDENTIFIER '{' (<function> | <sys_function>)* '}' ';'
  <function>            ::= 'fn' T_IDENTIFIER '(' <param_list> ')' '->' <type_specifier> '{' <block> '}' ';'
  <sys_function>        ::= 'sys' T_IDENTIFIER '(' <sys_param_list> ')' ('->' <type_specifier>)? '{' <block> '}' ';'
  <param_list>          ::= (<param> (',' <param>)*)?
  <param>               ::= T_IDENTIFIER ':' <type_specifier>
  <sys_param_list>      ::= (<sys_param> (',' <sys_param>)*)?
  <sys_param>           ::= <sys_type> ':' <sys_destination>
  <sys_type>            ::= 'byte' | 'word' | 'real'
  <sys_destination>     ::= 'a' | 'x' | 'y' | 'ay' | 'ax' | 'xy' | 'fac1' | 'fac2' | T_IDENTIFIER
  <type_specifier>      ::= T_POINTER* T_IDENTIFIER
  <block>               ::= <statement>*
  <statement>           ::= <declaration> | <const_declaration> | <asm_statement> | <expr_statement> | <return_statement>
  <return_statement>    ::= 'ret' <expr> ';'
  <declaration>         ::= T_IDENTIFIER ':' <type_specifier> ';'
  <const_declaration>   ::= T_IDENTIFIER ':' <expr> ';'
  <asm_statement>       ::= T_ASM_BLOCK ';'
  <expr_statement>      ::= <expr> ';'
  <expr>                ::= <assign>
  <assign>              ::= <logical_or_and> (':=' <assign>)?
  <logical_or_and>      ::= <equality> (('&&' | '||') <equality>)*
  <equality>            ::= <relational> (('?=' | '!=') <relational>)*
  <relational>          ::= <add_sub> (('<' | '<=' | '>' | '>=') <add_sub>)*
  <add_sub>             ::= <mul_div_mod> (('+' | '-') <mul_div_mod>)*
  <mul_div_mod>         ::= <unary> (('*' | '/' | '%%') <unary>)*
  <unary>               ::= ('++' | '--' | '+' | '-' | '!' | '@' | '^') <unary> | <postfix>
  <postfix>             ::= <term> ('++' | '--')*
  <term>                ::= T_INTEGER | T_REAL | T_STRING | <func_call> | T_IDENTIFIER | '(' <expr> ')'
  <func_call>           ::= (T_IDENTIFIER '::')? T_IDENTIFIER '(' <arg_list> ')'
  <arg_list>            ::= (<expr> (',' <expr>)*)?


--- End Parser Debug ---
